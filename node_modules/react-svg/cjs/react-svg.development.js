'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));
var SVGInjector = _interopDefault(require('@tanem/svg-injector'));
var PropTypes = require('prop-types');
var React = require('react');
var ReactDOMServer = _interopDefault(require('react-dom/server'));

// Hat-tip: https://github.com/developit/preact-compat/blob/master/src/index.js#L402.
var shallowDiffers = function shallowDiffers(a, b) {
  for (var i in a) {
    if (!(i in b)) {
      return true;
    }
  }

  for (var _i in b) {
    if (a[_i] !== b[_i]) {
      return true;
    }
  }

  return false;
};

var ReactSVG =
/*#__PURE__*/
function (_React$Component) {
  _inheritsLoose(ReactSVG, _React$Component);

  function ReactSVG() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.initialState = {
      hasError: false,
      isLoading: true
    };
    _this.state = _this.initialState;
    _this._isMounted = false;
    _this.container = void 0;
    _this.svgWrapper = void 0;

    _this.refCallback = function (container) {
      _this.container = container;
    };

    return _this;
  }

  var _proto = ReactSVG.prototype;

  _proto.renderSVG = function renderSVG() {
    var _this2 = this;

    if (this.container instanceof Node) {
      var _this$props = this.props,
          _evalScripts = _this$props.evalScripts,
          _renumerateIRIElements = _this$props.renumerateIRIElements,
          _src = _this$props.src,
          _svgClassName = _this$props.svgClassName,
          _svgStyle = _this$props.svgStyle;
      var _onInjected = this.props.onInjected;
      var Wrapper = this.props.wrapper;

      var _wrapper = document.createElement(Wrapper);

      _wrapper.innerHTML = ReactDOMServer.renderToStaticMarkup(React.createElement(Wrapper, null, React.createElement(Wrapper, {
        className: _svgClassName,
        "data-src": _src,
        style: _svgStyle
      })));
      this.svgWrapper = this.container.appendChild(_wrapper.firstChild);

      var each = function each(error, svg) {
        if (error) {
          _this2.removeSVG();
        } // TODO: It'd be better to cleanly unsubscribe from SVGInjector
        // callbacks instead of tracking a property like this.


        if (_this2._isMounted) {
          _this2.setState(function () {
            return {
              hasError: !!error,
              isLoading: false
            };
          }, function () {
            _onInjected(error, svg);
          });
        }
      };

      SVGInjector(this.svgWrapper.firstChild, {
        each: each,
        evalScripts: _evalScripts,
        renumerateIRIElements: _renumerateIRIElements
      });
    }
  };

  _proto.removeSVG = function removeSVG() {
    if (this.container instanceof Node && this.svgWrapper instanceof Node) {
      this.container.removeChild(this.svgWrapper);
      this.svgWrapper = null;
    }
  };

  _proto.componentDidMount = function componentDidMount() {
    this._isMounted = true;
    this.renderSVG();
  };

  _proto.componentDidUpdate = function componentDidUpdate(prevProps) {
    var _this3 = this;

    if (shallowDiffers(prevProps, this.props)) {
      this.setState(function () {
        return _this3.initialState;
      }, function () {
        _this3.removeSVG();

        _this3.renderSVG();
      });
    }
  };

  _proto.componentWillUnmount = function componentWillUnmount() {
    this._isMounted = false;
    this.removeSVG();
  };

  _proto.render = function render() {
    var _this$props2 = this.props,
        evalScripts = _this$props2.evalScripts,
        Fallback = _this$props2.fallback,
        Loading = _this$props2.loading,
        onInjected = _this$props2.onInjected,
        renumerateIRIElements = _this$props2.renumerateIRIElements,
        src = _this$props2.src,
        svgClassName = _this$props2.svgClassName,
        svgStyle = _this$props2.svgStyle,
        wrapper = _this$props2.wrapper,
        rest = _objectWithoutPropertiesLoose(_this$props2, ["evalScripts", "fallback", "loading", "onInjected", "renumerateIRIElements", "src", "svgClassName", "svgStyle", "wrapper"]);

    var Wrapper = wrapper;
    return React.createElement(Wrapper, _extends({}, rest, {
      ref: this.refCallback
    }), this.state.isLoading && Loading && React.createElement(Loading, null), this.state.hasError && Fallback && React.createElement(Fallback, null));
  };

  return ReactSVG;
}(React.Component);

ReactSVG.defaultProps = {
  evalScripts: 'never',
  fallback: null,
  loading: null,
  onInjected: function onInjected() {
    return undefined;
  },
  renumerateIRIElements: true,
  svgClassName: null,
  svgStyle: {},
  wrapper: 'div'
};
ReactSVG.propTypes = {
  evalScripts: PropTypes.oneOf(['always', 'once', 'never']),
  fallback: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]),
  loading: PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.string]),
  onInjected: PropTypes.func,
  renumerateIRIElements: PropTypes.bool,
  src: PropTypes.string.isRequired,
  svgClassName: PropTypes.string,
  svgStyle: PropTypes.object,
  wrapper: PropTypes.oneOf(['div', 'span'])
};

module.exports = ReactSVG;
//# sourceMappingURL=react-svg.development.js.map
